
// ğŸ”§ å®Œå…¨é‡å»ºçš„æ ¸å¿ƒAPIçµæ§‹
const express = require('express');
const jwt = require('jsonwebtoken');
const fs = require('fs');
const path = require('path');
const cors = require('cors');

const app = express();

// ğŸ›¡ï¸ åŸºç¤ä¸­é–“ä»¶è¨­ç½® (æ¸…ç†ç‰ˆ)
app.use(cors({
    origin: process.env.FRONTEND_URL || 'https://gclaude-enterprise-system.onrender.com',
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization'],
    credentials: true
}));

app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ extended: true, limit: '50mb' }));

// ğŸ—‚ï¸ æ•¸æ“šå­˜å„²è·¯å¾‘
const DATA_DIR = path.join(__dirname, 'data');
if (!fs.existsSync(DATA_DIR)) {
    fs.mkdirSync(DATA_DIR, { recursive: true });
}

// ğŸ” JWTé…ç½®
const JWT_SECRET = process.env.JWT_SECRET || 'gclaude-enterprise-secret-2025';

// ğŸ›¡ï¸ ç°¡åŒ–èªè­‰ä¸­é–“ä»¶
function authenticateToken(req, res, next) {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];
    
    if (!token) {
        return res.status(401).json({ 
            success: false, 
            message: 'Access token required' 
        });
    }
    
    try {
        const decoded = jwt.verify(token, JWT_SECRET);
        req.user = decoded;
        next();
    } catch (error) {
        return res.status(403).json({ 
            success: false, 
            message: 'Invalid token' 
        });
    }
}

// ğŸ¥ PHASE 1: åŸºç¤å¥åº·æª¢æŸ¥ç«¯é» (æ¸…ç†é‡å»º)
app.get('/health', (req, res) => {
    res.status(200).json({
        success: true,
        status: 'healthy',
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
        memory: process.memoryUsage()
    });
});

app.get('/ready', (req, res) => {
    // æª¢æŸ¥ç³»çµ±å°±ç·’ç‹€æ…‹
    const checks = {
        dataDir: fs.existsSync(DATA_DIR),
        memory: process.memoryUsage().heapUsed < 100 * 1024 * 1024, // <100MB
        uptime: process.uptime() > 10 // >10 seconds
    };
    
    const allReady = Object.values(checks).every(check => check);
    
    res.status(allReady ? 200 : 503).json({
        success: allReady,
        status: allReady ? 'ready' : 'not_ready',
        checks: checks,
        timestamp: new Date().toISOString()
    });
});

// ğŸ” PHASE 2: èªè­‰APIé‡å»º
app.post('/api/auth/login', (req, res) => {
    const { username, password } = req.body;
    
    // ç°¡åŒ–èªè­‰é‚è¼¯
    if (username === 'admin' && password === 'admin123') {
        const token = jwt.sign(
            { username: username, role: 'admin' },
            JWT_SECRET,
            { expiresIn: '24h' }
        );
        
        res.json({
            success: true,
            token: token,
            user: { username: username, role: 'admin' },
            expiresIn: '24h'
        });
    } else {
        res.status(401).json({
            success: false,
            message: 'Invalid credentials'
        });
    }
});

app.post('/api/auth/verify', (req, res) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];
    
    if (!token) {
        return res.status(401).json({ success: false, message: 'No token provided' });
    }
    
    try {
        const decoded = jwt.verify(token, JWT_SECRET);
        res.json({
            success: true,
            user: decoded,
            valid: true
        });
    } catch (error) {
        res.status(403).json({
            success: false,
            message: 'Invalid token',
            valid: false
        });
    }
});

app.post('/api/auth/refresh', authenticateToken, (req, res) => {
    const newToken = jwt.sign(
        { username: req.user.username, role: req.user.role },
        JWT_SECRET,
        { expiresIn: '24h' }
    );
    
    res.json({
        success: true,
        token: newToken,
        expiresIn: '24h'
    });
});

// ğŸ“Š PHASE 3: ç³»çµ±ç›£æ§APIé‡å»º
app.get('/api/system/status', (req, res) => {
    const status = {
        success: true,
        status: 'operational',
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
        memory: process.memoryUsage(),
        platform: process.platform,
        nodeVersion: process.version,
        environment: process.env.NODE_ENV || 'production'
    };
    
    res.json(status);
});

app.get('/api/system/health', (req, res) => {
    const healthChecks = {
        api: true,
        database: fs.existsSync(DATA_DIR),
        memory: process.memoryUsage().heapUsed < 200 * 1024 * 1024,
        uptime: process.uptime() > 30
    };
    
    const overall = Object.values(healthChecks).every(check => check);
    
    res.status(overall ? 200 : 503).json({
        success: overall,
        status: overall ? 'healthy' : 'unhealthy',
        checks: healthChecks,
        timestamp: new Date().toISOString()
    });
});

app.get('/api/system/monitor', (req, res) => {
    const monitoring = {
        success: true,
        metrics: {
            uptime: process.uptime(),
            memory: process.memoryUsage(),
            cpu: process.cpuUsage(),
            timestamp: new Date().toISOString()
        },
        alerts: [],
        status: 'monitoring_active'
    };
    
    res.json(monitoring);
});

app.get('/api/system/memory', (req, res) => {
    const memoryInfo = {
        success: true,
        memory: process.memoryUsage(),
        formatted: {
            rss: `${(process.memoryUsage().rss / 1024 / 1024).toFixed(2)}MB`,
            heapTotal: `${(process.memoryUsage().heapTotal / 1024 / 1024).toFixed(2)}MB`,
            heapUsed: `${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB`,
            external: `${(process.memoryUsage().external / 1024 / 1024).toFixed(2)}MB`
        },
        timestamp: new Date().toISOString()
    };
    
    res.json(memoryInfo);
});

// ğŸ“¦ PHASE 4: æ ¸å¿ƒæ¥­å‹™APIé‡å»º
app.get('/api/profile', authenticateToken, (req, res) => {
    const profilePath = path.join(DATA_DIR, 'profiles', `${req.user.username}.json`);
    
    if (fs.existsSync(profilePath)) {
        try {
            const profile = JSON.parse(fs.readFileSync(profilePath, 'utf8'));
            res.json({
                success: true,
                profile: profile
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: 'Error reading profile'
            });
        }
    } else {
        // å»ºç«‹é»˜èªprofile
        const defaultProfile = {
            username: req.user.username,
            role: req.user.role,
            createdAt: new Date().toISOString(),
            settings: {}
        };
        
        res.json({
            success: true,
            profile: defaultProfile
        });
    }
});

app.get('/api/inventory', authenticateToken, (req, res) => {
    const inventoryPath = path.join(DATA_DIR, 'inventory.json');
    
    let inventory = [];
    if (fs.existsSync(inventoryPath)) {
        try {
            inventory = JSON.parse(fs.readFileSync(inventoryPath, 'utf8'));
        } catch (error) {
            inventory = [];
        }
    }
    
    res.json({
        success: true,
        inventory: inventory,
        count: inventory.length,
        timestamp: new Date().toISOString()
    });
});

// ğŸŒ é¦–é è·¯ç”±
app.get('/', (req, res) => {
    res.json({
        success: true,
        message: 'GClaude Enterprise Management System',
        status: 'operational',
        version: '2.0.0-rebuilt',
        timestamp: new Date().toISOString(),
        endpoints: [
            '/health',
            '/ready', 
            '/api/auth/login',
            '/api/auth/verify',
            '/api/auth/refresh',
            '/api/system/status',
            '/api/system/health',
            '/api/system/monitor',
            '/api/system/memory',
            '/api/profile',
            '/api/inventory'
        ]
    });
});

// ğŸš¨ çµ±ä¸€éŒ¯èª¤è™•ç†
app.use((err, req, res, next) => {
    console.error('Server Error:', err);
    res.status(500).json({
        success: false,
        message: 'Internal server error',
        timestamp: new Date().toISOString()
    });
});

// ğŸ” 404è™•ç†
app.use('*', (req, res) => {
    res.status(404).json({
        success: false,
        message: 'Endpoint not found',
        path: req.originalUrl,
        method: req.method,
        timestamp: new Date().toISOString(),
        suggestion: 'Check /api endpoints or /'
    });
});

// ğŸš€ æœå‹™å™¨å•Ÿå‹•
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
    console.log(`ğŸš€ GClaude Enterprise System (Rebuilt) running on port ${PORT}`);
    console.log(`ğŸŒ Environment: ${process.env.NODE_ENV || 'production'}`);
    console.log(`ğŸ•’ Started at: ${new Date().toISOString()}`);
});

module.exports = app;
